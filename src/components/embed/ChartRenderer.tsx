/**
 * Renders a chart component based on chartType from registry entry.
 * Lazy imports chart components to keep embed bundle small.
 * Always passes isVisible={true} (no scroll animations in embeds).
 */
import { lazy, Suspense } from 'react';
import type { ChartType } from '../../lib/chartRegistry.ts';

const LineChart = lazy(() => import('../viz/LineChart.tsx').then((m) => ({ default: m.LineChart })));
const AreaChart = lazy(() => import('../viz/AreaChart.tsx').then((m) => ({ default: m.AreaChart })));
const HorizontalBarChart = lazy(() => import('../viz/HorizontalBarChart.tsx').then((m) => ({ default: m.HorizontalBarChart })));
const TreemapChart = lazy(() => import('../viz/TreemapChart.tsx').then((m) => ({ default: m.TreemapChart })));
const SankeyDiagram = lazy(() => import('../viz/SankeyDiagram.tsx').then((m) => ({ default: m.SankeyDiagram })));
const WaffleChart = lazy(() => import('../viz/WaffleChart.tsx').then((m) => ({ default: m.WaffleChart })));
const ChoroplethMap = lazy(() => import('../viz/ChoroplethMap.tsx').then((m) => ({ default: m.ChoroplethMap })));

interface ChartRendererProps {
  chartType: ChartType;
  data: unknown;
  domain: string;
  sectionId: string;
}

/**
 * Note: This is a best-effort renderer. For complex sections that combine
 * multiple charts or custom layouts, the embed may only show the primary chart.
 * Full fidelity requires section-specific embed handling (future enhancement).
 */
export function ChartRenderer({ chartType, data, domain, sectionId }: ChartRendererProps) {
  return (
    <Suspense
      fallback={
        <div style={{ padding: 40, textAlign: 'center', color: 'var(--text-muted)' }}>
          Loading chart...
        </div>
      }
    >
      <ChartSwitch chartType={chartType} data={data} domain={domain} sectionId={sectionId} />
    </Suspense>
  );
}

function ChartSwitch({ chartType, data, domain, sectionId }: ChartRendererProps) {
  const d = data as Record<string, unknown>;

  switch (chartType) {
    case 'line':
      return renderLineChart(d, domain, sectionId);
    case 'area':
      return renderAreaChart(d, domain, sectionId);
    case 'horizontal-bar':
      return renderBarChart(d, domain, sectionId);
    case 'treemap':
      return <TreemapChart root={(d as { root: never }).root} isVisible={true} />;
    case 'sankey':
      return <SankeyDiagram data={d as never} isVisible={true} />;
    case 'waffle':
      return <WaffleChart categories={(d as { categories: never[] }).categories} isVisible={true} />;
    case 'choropleth':
      return <ChoroplethMap states={(d as { states: never[] }).states} isVisible={true} />;
    default:
      return (
        <div style={{ padding: 40, textAlign: 'center', color: 'var(--text-muted)' }}>
          This chart type is not available for embedding yet.
        </div>
      );
  }
}

// ─── Type-specific render helpers ─────────────────────────────────────

function renderLineChart(data: Record<string, unknown>, domain: string, sectionId: string) {
  // Build series from known data shapes
  const series = buildLineSeries(data, domain, sectionId);
  if (!series.length) {
    return <div style={{ color: 'var(--text-muted)', padding: 20 }}>No data available</div>;
  }
  return <LineChart series={series} isVisible={true} />;
}

function renderAreaChart(data: Record<string, unknown>, domain: string, sectionId: string) {
  const series = buildAreaSeries(data, domain, sectionId);
  if (!series.length) {
    return <div style={{ color: 'var(--text-muted)', padding: 20 }}>No data available</div>;
  }
  return <AreaChart series={series} isVisible={true} />;
}

function renderBarChart(data: Record<string, unknown>, _domain: string, _sectionId: string) {
  // Look for common bar data shapes
  const states = (data as { states?: { name: string; value: number; id: string }[] }).states;
  if (states) {
    const items = states
      .sort((a: { value: number }, b: { value: number }) => b.value - a.value)
      .slice(0, 15)
      .map((s: { id: string; name: string; value: number }) => ({
        id: s.id,
        label: s.name,
        value: s.value,
      }));
    return <HorizontalBarChart items={items} isVisible={true} />;
  }
  return <div style={{ color: 'var(--text-muted)', padding: 20 }}>No data available</div>;
}

// ─── Series builders ──────────────────────────────────────────────────

interface TimePoint {
  year: string;
  value: number;
}

interface SeriesShape {
  id: string;
  name: string;
  color: string;
  data: TimePoint[];
  dashed?: boolean;
}

function buildLineSeries(data: Record<string, unknown>, domain: string, sectionId: string): SeriesShape[] {
  const colors = ['var(--cyan)', 'var(--saffron)', 'var(--gold)', '#a78bfa', 'var(--emerald)'];
  const series: SeriesShape[] = [];

  // Known data shapes by domain/section
  if (domain === 'economy' && sectionId === 'growth') {
    const d = data as { series: TimePoint[] };
    if (d.series?.length) {
      series.push({ id: 'gdp', name: 'Real GDP Growth', color: colors[0], data: d.series });
    }
  } else if (domain === 'economy' && sectionId === 'inflation') {
    const d = data as { series: { period: string; cpiHeadline: number }[] };
    if (d.series?.length) {
      series.push({
        id: 'cpi',
        name: 'CPI Headline',
        color: colors[1],
        data: d.series.map((p) => ({ year: p.period, value: p.cpiHeadline })),
      });
    }
  } else {
    // Generic: look for time series fields
    for (const [key, val] of Object.entries(data)) {
      if (key.endsWith('TimeSeries') && Array.isArray(val) && val.length >= 3) {
        const name = key.replace('TimeSeries', '').replace(/([A-Z])/g, ' $1').trim();
        series.push({
          id: key,
          name,
          color: colors[series.length % colors.length],
          data: val as TimePoint[],
        });
      }
    }
    // Also check nested 'series' field
    if ('series' in data && Array.isArray(data.series) && data.series.length > 0) {
      const pts = data.series as TimePoint[];
      if (pts[0]?.year && pts[0]?.value !== undefined) {
        series.push({ id: 'primary', name: 'Value', color: colors[0], data: pts });
      }
    }
  }

  return series;
}

function buildAreaSeries(data: Record<string, unknown>, domain: string, sectionId: string): SeriesShape[] {
  const colors = ['var(--cyan)', 'var(--saffron)', 'var(--gold)'];
  const series: SeriesShape[] = [];

  if (domain === 'economy' && sectionId === 'sectors') {
    const d = data as { sectors: { id: string; name: string; currentGrowth: number; gvaShare: number }[] };
    // Sectors data isn't time-series based for area chart in embed; fall back to line-style
    if (d.sectors?.length) {
      return [];
    }
  }

  // Generic: look for time series fields
  for (const [key, val] of Object.entries(data)) {
    if (key.endsWith('TimeSeries') && Array.isArray(val) && val.length >= 3) {
      const name = key.replace('TimeSeries', '').replace(/([A-Z])/g, ' $1').trim();
      series.push({
        id: key,
        name,
        color: colors[series.length % colors.length],
        data: val as TimePoint[],
      });
    }
  }

  return series;
}
